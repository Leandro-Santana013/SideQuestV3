"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkArrayLength = exports.maybeToPrecision = void 0;
const is_any_array_1 = require("is-any-array");
const checkArrayLength_1 = __importDefault(require("./checkArrayLength"));
exports.checkArrayLength = checkArrayLength_1.default;
var maybeToPrecision_1 = require("./maybeToPrecision");
Object.defineProperty(exports, "maybeToPrecision", { enumerable: true, get: function () { return __importDefault(maybeToPrecision_1).default; } });
class BaseRegression {
    constructor() {
        if (new.target === BaseRegression) {
            throw new Error('BaseRegression must be subclassed');
        }
    }
    predict(x) {
        if (typeof x === 'number') {
            return this._predict(x);
        }
        else if ((0, is_any_array_1.isAnyArray)(x)) {
            const y = [];
            for (const xVal of x) {
                y.push(this._predict(xVal));
            }
            return y;
        }
        else {
            throw new TypeError('x must be a number or array');
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _predict(x) {
        throw new Error('_predict must be implemented');
    }
    train() {
        // Do nothing for this package
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toString(precision) {
        return '';
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toLaTeX(precision) {
        return '';
    }
    /**
     * Return the correlation coefficient of determination (r) and chi-square.
     * @param x - explanatory variable
     * @param y - response variable
     * @return - Object with further statistics.
     */
    score(x, y) {
        (0, checkArrayLength_1.default)(x, y);
        const n = x.length;
        const y2 = new Array(n);
        for (let i = 0; i < n; i++) {
            y2[i] = this._predict(x[i]);
        }
        let xSum = 0;
        let ySum = 0;
        let chi2 = 0;
        let rmsd = 0;
        let xSquared = 0;
        let ySquared = 0;
        let xY = 0;
        for (let i = 0; i < n; i++) {
            xSum += y2[i];
            ySum += y[i];
            xSquared += y2[i] * y2[i];
            ySquared += y[i] * y[i];
            xY += y2[i] * y[i];
            if (y[i] !== 0) {
                chi2 += ((y[i] - y2[i]) * (y[i] - y2[i])) / y[i];
            }
            rmsd += (y[i] - y2[i]) * (y[i] - y2[i]);
        }
        const r = (n * xY - xSum * ySum) /
            Math.sqrt((n * xSquared - xSum * xSum) * (n * ySquared - ySum * ySum));
        return {
            r,
            r2: r * r,
            chi2,
            rmsd: Math.sqrt(rmsd / n),
        };
    }
}
exports.default = BaseRegression;
//# sourceMappingURL=index.js.map