"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ifd_1 = __importDefault(require("./ifd"));
// eslint-disable-next-line prefer-named-capture-group
const dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
class TiffIfd extends ifd_1.default {
    constructor() {
        super('standard');
    }
    // Custom fields
    get size() {
        return this.width * this.height;
    }
    get width() {
        return this.imageWidth;
    }
    get height() {
        return this.imageLength;
    }
    get components() {
        return this.samplesPerPixel;
    }
    get date() {
        let date = new Date();
        let result = dateTimeRegex.exec(this.dateTime);
        if (result === null) {
            throw new Error(`invalid dateTime: ${this.dateTime}`);
        }
        date.setFullYear(Number(result[1]), Number(result[2]) - 1, Number(result[3]));
        date.setHours(Number(result[4]), Number(result[5]), Number(result[6]));
        return date;
    }
    // IFD fields
    get newSubfileType() {
        return this.get('NewSubfileType');
    }
    get imageWidth() {
        return this.get('ImageWidth');
    }
    get imageLength() {
        return this.get('ImageLength');
    }
    get bitsPerSample() {
        const data = this.get('BitsPerSample');
        if (data && typeof data !== 'number') {
            return data[0];
        }
        return data;
    }
    get alpha() {
        const extraSamples = this.extraSamples;
        if (!extraSamples)
            return false;
        return extraSamples[0] !== 0;
    }
    get associatedAlpha() {
        const extraSamples = this.extraSamples;
        if (!extraSamples)
            return false;
        return extraSamples[0] === 1;
    }
    get extraSamples() {
        return alwaysArray(this.get('ExtraSamples'));
    }
    get compression() {
        return this.get('Compression') || 1;
    }
    get type() {
        return this.get('PhotometricInterpretation');
    }
    get fillOrder() {
        return this.get('FillOrder') || 1;
    }
    get documentName() {
        return this.get('DocumentName');
    }
    get imageDescription() {
        return this.get('ImageDescription');
    }
    get stripOffsets() {
        return alwaysArray(this.get('StripOffsets'));
    }
    get orientation() {
        return this.get('Orientation');
    }
    get samplesPerPixel() {
        return this.get('SamplesPerPixel') || 1;
    }
    get rowsPerStrip() {
        return this.get('RowsPerStrip');
    }
    get stripByteCounts() {
        return alwaysArray(this.get('StripByteCounts'));
    }
    get minSampleValue() {
        return this.get('MinSampleValue') || 0;
    }
    get maxSampleValue() {
        return this.get('MaxSampleValue') || Math.pow(2, this.bitsPerSample) - 1;
    }
    get xResolution() {
        return this.get('XResolution');
    }
    get yResolution() {
        return this.get('YResolution');
    }
    get planarConfiguration() {
        return this.get('PlanarConfiguration') || 1;
    }
    get resolutionUnit() {
        return this.get('ResolutionUnit') || 2;
    }
    get dateTime() {
        return this.get('DateTime');
    }
    get predictor() {
        return this.get('Predictor') || 1;
    }
    get sampleFormat() {
        return this.get('SampleFormat') || 1;
    }
    get sMinSampleValue() {
        return this.get('SMinSampleValue') || this.minSampleValue;
    }
    get sMaxSampleValue() {
        return this.get('SMaxSampleValue') || this.maxSampleValue;
    }
    get palette() {
        const totalColors = 2 ** this.bitsPerSample;
        const colorMap = this.get('ColorMap');
        if (!colorMap)
            return undefined;
        if (colorMap.length !== 3 * totalColors) {
            throw new Error(`ColorMap size must be ${totalColors}`);
        }
        const palette = [];
        for (let i = 0; i < totalColors; i++) {
            palette.push([
                colorMap[i],
                colorMap[i + totalColors],
                colorMap[i + 2 * totalColors],
            ]);
        }
        return palette;
    }
}
exports.default = TiffIfd;
function alwaysArray(value) {
    if (typeof value === 'number')
        return [value];
    return value;
}
//# sourceMappingURL=tiffIfd.js.map